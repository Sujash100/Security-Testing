option "--one-role-per-agent";

usertype Timestamp;
#usertype NIZK;
usertype Challenge;
usertype Signature;
usertype Epochkey;
usertype Publicparameters;
usertype Epochinfo;
usertype NAK;
usertype Generator;


const pkCA: Function;
secret skCA: Function;
inversekeys (pkCA,skCA);

const pk2: Function;
secret sk2: Function;
inversekeys (pk2,sk2);


/*Global Parameters and functions*/
const pp: Publicparameters;
const G1: Generator;
const G2: Generator;
hashfunction H;
secret exp: Function; /* this function works as a DH-key agreement */
/* In an attack scenerio when the the secret key of vehicle or the secret key of LI is compromised, the exp function is no more Secret function*/
/* When exp is not a secret function, define it as const*/
#const exp: Function;
secret NIZK: Function;



/*Macros*/
macro sigLI =  {H(pk(LI))}skCA; /* This is the dummy (publicly available)signature on the LI's public key initially generated by CA*/
#macro n2= {pk2(Vehicle),nizk,{pp,nizk,T1}sk2(Vehicle),T1}exp(pk(LI),sk2(Vehicle)); /* this is the authentication tuple*/
macro n2= (pk2(Vehicle),NIZK(ch,si),{pp,NIZK(ch,si),T1}sk2(Vehicle),T1);     /* this is the authentication tuple*/
macro n3= {pk(LI),einfo,ek,{pp,pk2(Vehicle),pk(LI),einfo,T1}sk(LI)}exp(pk2(Vehicle),sk(LI)); /* this is the response tuple*/


/* Attack specific*/
#const fake: Nonce; /* send a fake signature of LI public key to pass verification*/ 
#macro sigLIfake = {H(pk(LI),fake)}skCA;

/* This helper protocol let the adversary know that exp(a,b)=exp(b,a)*/
protocol @symkey(X,Y)
{
	role X{
	var m: Ticket;
	var Y: Agent;
	recv_!1(X,X, exp(pk2(X),sk(Y)) );
	send_!2(X,X, exp(pk(Y),sk2(X)) );
	}
	role Y {
	var X: Agent;
	var m: Ticket;
	recv_!3(Y,Y, { m }exp(pk2(X),sk(Y)) );
	send_!4(Y,Y, { m }exp(pk(Y),sk2(X)) );
	}
}

protocol V2I(Vehicle, LI) 
{ /* Start V2I Protocol*/
secret si; /* assumed shared secret of LI and Vehicle by CA initilly*/
macro prove=NIZK(ch,si); /* dummy  prove to check the validity of the received zero knowledge nizk*/

				role Vehicle{


					/*Receive and check the validity of  the public key of the LI and its signature*/

					recv_!n1(LI,Vehicle,pk(LI),{H(pk(LI))}skCA);
					match(sigLI,{H(pk(LI))}skCA);


					/* Values generated by the Vehicle for authentication*/

					fresh ch: Challenge;
					fresh T1: Timestamp;
					



					/*Attack: Sends information to the adversary that public Keys are unique per run (with the value)*/
					#send_!rpk(Vehicle, Vehicle, pk2(Vehicle));

					/*Attack: Compromise the Vehicle's secret Key  (with the value)*/
					send_!rsk(Vehicle, Vehicle, sk2(Vehicle));
					/* const exp: Function;*/

					/* Attack: Send information to the adversary that nizks are unique per run (with the value)*/
					send_!ni(Vehicle, Vehicle, si);

					/* Attack: Sends information to the adversary that Time-stamps are unique per run (with the value)*/
					send_!T1(Vehicle, Vehicle, T1);

					
					
					/*send authentication request*/
					send_n2(Vehicle, LI, n2);

					/*receive authentication acknowledgement and epoch key*/
					var einfo: Epochinfo;
					var ek: Epochkey;
					recv_n3(LI,Vehicle,n3);


					

#send_1(Vs,LI,{pk(Vs),nizk,{nizk}sk(Vs), T}k(Vs,LI));

/* Security Claims*/

claim_r1(Vehicle,Secret,pk2(Vehicle));
claim_r2(Vehicle,Secret,sk2(Vehicle));
#claim_r3(Vehicle,Secret,nizk);
claim_r4(Vehicle,Niagree);
claim_r5(Vehicle,Nisynch);
claim_r6(Vehicle, Weakagree);
claim_r7(Vehicle, Secret,ek);
claim_r8(Vehicle, Secret, si);
claim_r8(Vehicle, Alive);


						} 	/* END OF ROLE Vehicle*/

				role LI{ 	/* BEGIN ROLE LI*/
					
					/* LI generates session specific values*/
					fresh ek: Epochkey;
					fresh einfo: Epochinfo;
					fresh nak:NAK;
					
					/* LI sends its public key and signature to the requesting vehicle*/
					send_!n1(LI, Vehicle, pk(LI),{H(pk(LI))}skCA);

					/* parameters to receive in authentication tuple*/
					
					var T1: Timestamp;
					var ch: Challenge;

					recv_n2(Vehicle, LI, n2); /* The Authentication tuple is received*/

					#match(H(nizk,si),prove); /* Verify if the prove is true based on the secret si*/
					match(NIZK(ch,si),prove); 
					send_n3(LI,Vehicle,n3); /* if true, response with n3 */
					
					

					


/* Security Claims*/
claim_s1(LI,Secret,sk(LI));
claim_s2(LI, Secret,ek);
claim_s3(LI,Niagree);
claim_s4(LI,Nisynch);
claim_s5(LI, Weakagree);
#claim_s6(LI,Secret,pk2(Vehicle));
claim_s6(LI, Alive);

					}	/* END ROLE LI*/


};	/* END Protocol*/
