option "--one-role-per-agent";

usertype Timestamp;
usertype Challenge;
usertype Signature;
usertype Epochkey;
usertype Publicparameters;
usertype Epochinfo;
usertype NAK;
usertype Generator;


const pkCA: Function;
secret skCA: Function;
inversekeys (pkCA,skCA);

const pk2: Function;
secret sk2: Function;
inversekeys (pk2,sk2);


/*Global Parameters and functions*/
const pp: Publicparameters;
hashfunction H;
secret exp: Function; /* this function works as a DH-key agreement */
secret NIZK: Function;




/*Macros*/
macro sigLI =  {H(pk(LI))}skCA; /* This is the dummy (publicly available)signature on the LI's public key initially generated by CA*/
macro n2= pk2(Vehicle),NIZK(ch,si),{pp,NIZK(ch,si),T1}sk2(Vehicle),T1; /* this is the authentication tuple*/
#macro n2= {pk2(Vehicle),NIZK(ch,si),{pp,NIZK(ch,si),T1}sk2(Vehicle),T1}exp(pk(LI),sk2(Vehicle)); /* this is the authentication tuple*/
macro n3= {pk(LI),einfo,ek,{pp,pk2(Vehicle),pk(LI),einfo,T1}sk(LI)}exp(pk2(Vehicle),sk(LI)); /* this is the response tuple*/


/* Attack specific*/

/* send a fake signature of LI public key to pass verification*/ 
	#const fake: Nonce; 
	#macro sigLIfake = {H(pk(LI),fake)}skCA;

/*Simulate a situation where sk2(Vehicle) is compromised, then turn on the following statements*/
	#macro n2= (pk2(Vehicle),NIZK(ch,si),{pp,NIZK(ch,si),T1}sk2(Vehicle),T1); /* as sk2(Vehicle) is leaked, the DH-symmetric key is not anymore secret, so remove the symmetric encryption*/

/* In an attack scenerio when the the secret key of vehicle or the secret key of LI is compromised, the exp function is no more Secret function. When exp is not a secret function, define it as const*/
#const exp: Function;

/*Simulate when NIZK is compromized*/
	#const NIZK: Function; /* Only when NIZK is compromized*/

/* This helper protocol let the adversary know that exp(a,b)=exp(b,a)*/
protocol @symkey(X,Y)
{
	role X{
	var m: Ticket;
	var Y: Agent;
	recv_!1(X,X, exp(pk2(X),sk(Y)) );
	send_!2(X,X, exp(pk(Y),sk2(X)) );
	}
	role Y {
	var X: Agent;
	var m: Ticket;
	recv_!3(Y,Y, { m }exp(pk2(X),sk(Y)) );
	send_!4(Y,Y, { m }exp(pk(Y),sk2(X)) );
	}
}

protocol V2I(Vehicle, LI) 
{ /* Start V2I Protocol*/
secret si; /* assumed shared secret of LI and Vehicle by CA initilly*/
macro prove=NIZK(ch,si); /* dummy  prove to check the validity of the received zero knowledge nizk*/

				role Vehicle{

					/* Values generated by the Vehicle for authentication*/

					#fresh nizk:NIZK;
					fresh ch: Challenge;
					fresh T1: Timestamp;
					

					/*Receive and check the validity of  the public key of the LI and its signature*/
					recv_!n1(LI,Vehicle,pk(LI),{H(pk(LI))}skCA);
					match(sigLI,{H(pk(LI))}skCA);

					/*Attack: Sends information to the adversary that public Keys are unique per run (with the value)*/
					send_!rpk(Vehicle, Vehicle, pk2(Vehicle));

					/*Attack: Compromise the Vehicle's secret Key  (with the value)*/
					send_!rsk(Vehicle, Vehicle, sk2(Vehicle));
					/* const exp: Function;*/

					/* Attack: Send information to the adversary that nizks are unique per run (with the value)*/
					#send_!ni(Vehicle, Vehicle, si);

					/* Attack: Sends information to the adversary that Time-stamps are unique per run (with the value)*/
					#send_!T1(Vehicle, Vehicle, T1);

					
					
					/*send authentication request*/
					send_n2(Vehicle, LI, n2);

					/*receive authentication acknowledgement and epoch key*/
					var einfo: Epochinfo;
					var ek: Epochkey;
					recv_n3(LI,Vehicle,n3);


					

#send_1(Vs,LI,{pk(Vs),nizk,{nizk}sk(Vs), T}k(Vs,LI));

/* Security Claims*/

#claim_r1(Vehicle,Secret,pk2(Vehicle)); /* false check*/
claim_r2(Vehicle,Secret,sk2(Vehicle));
#claim_r3(Vehicle,Secret,nizk);
claim_r4(Vehicle,Niagree);
claim_r5(Vehicle,Nisynch);
claim_r6(Vehicle, Weakagree);
claim_r7(Vehicle, Secret,ek);
claim_r8(Vehicle, Secret, si);
claim_r8(Vehicle, Alive);


						} 	/* END OF ROLE Vehicle*/

				role LI{ 	/* BEGIN ROLE LI*/
					
					/* LI generates session specific values*/
					fresh ek: Epochkey;
					fresh einfo: Epochinfo;
					fresh nak:NAK;
					
					/* LI sends its public key and signature to the requesting vehicle*/
					send_!n1(LI, Vehicle, pk(LI),{H(pk(LI))}skCA);

					/* parameters to receive in authentication tuple*/
					#var nizk:NIZK;
					
					var T1: Timestamp;
					var ch: Challenge;

					recv_n2(Vehicle, LI, n2); /* The Authentication tuple is received*/

					 
					match(NIZK(ch,si),prove); /* Verify if the prove is true based on the secret si*/

					send_n3(LI,Vehicle,n3); /* if true, response with n3 */
					
					

					


/* Security Claims*/
claim_s1(LI,Secret,sk(LI));
claim_s2(LI, Secret,ek);
claim_s3(LI,Niagree);
claim_s4(LI,Nisynch);
claim_s5(LI, Weakagree);
#claim_s6(LI,Secret,pk2(Vehicle));
claim_s6(LI, Alive);

					}	/* END ROLE LI*/


};	/* END Protocol*/


/* Macros used in V2V Protocol*/

macro sigVS={H(pk2(VS))}skLI;
macro sigVS={H(pk2(VR))}skLI;
macro n4={pk2(VS),msg,T2,{H(pk2(VS))}skLI, {msg,pp,pk2(VS),T2}sk2(VS)}ek(VS,VR);
#macro n5={pk2(VR),msgr,T2,{H(pk2(VR))}skLI, {msgr,pp,pk2(VR),T2}sk2(VR)}ek(VS,VR);


protocol V2V(VS,VR){
/*begin the V2V protocol*/
/* Protocol Specific Secret and Knowledge*/
secret ek: Function;
const pkLI: Function;
secret skLI: Function;
inversekeys(pkLI, skLI);

				role VS{ /*Start the role of VS*/
						fresh msg: Data;
						fresh T2: Timestamp;
						#send_!n4(VS,VR, pk2(VS),{{H(pk2(VS))}skLI}ek(VS,VR)); /* Share Public key and signature with surrounding Vehicles*/
						recv_!n5(VR,VS, pk2(VR),{{H(pk2(VR))}skLI}ek(VS,VR));
						send_n4(VS,VR,n4);

						/* maybe VR also send someting to VS? then turn on the below statements*/
						#var msgr: Data;
						#var T3: Timestamp;
						#recv_n5(VR,VS,n5);

/* Security Claims*/
#claim_v1(VS,Secret,sk2(VS));
#claim_v2(VS, Secret,msg);
#claim_v3(VS,Secret,T2);
claim_v4(VS,Niagree);
claim_v5(VS,Nisynch);
claim_v6(VS, Weakagree);
#claim_v7(VS,Secret,sk2(VS));
claim_v8(VS,Alive);

						}/* End the role of VS*/

				role VR{ /*Start the role of VR*/
						
						var msg: Data;
						var T2: Timestamp;
						
						send_!n5(VR,VS, pk2(VR),{{H(pk2(VR))}skLI}ek(VS,VR)); /* Share Public key and signature with surrounding Vehicles*/
						#recv_!n4(VS,VR, pk2(VS),{{H(pk2(VS))}skLI}ek(VS,VR));
						recv_n4(VS,VR,n4);
						#match({H(pk2(VS))}skLI, sigVS);

						/* To check the security when VR also sends a message msgr to the sender VS*/
						#fresh msgr: Data;
						#fresh T3: Timestamp;
						#send_n5(VR,VS,n5);

/* Security Claims*/
claim_x1(VR,Secret,sk2(VR));
#claim_x2(VR, Secret,msg);
#claim_x3(VR,Secret,T2);
claim_x4(VR,Niagree);
claim_x5(VR,Nisynch);
claim_x6(VR, Weakagree);
#claim_x7(VR,Secret,sk2(VS));
claim _x8(VR, Alive);

						}/*End the role of VR*/

};/* End of V2V protocol*/